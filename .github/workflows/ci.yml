name: O-RAN Intent-MANO CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      run_performance_tests:
        description: 'Run performance tests'
        required: false
        default: 'false'
        type: boolean
      run_e2e_tests:
        description: 'Run E2E tests'
        required: false
        default: 'false'
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/${{ github.repository_owner }}
  GO_VERSION: '1.24.5'
  KIND_VERSION: 'v0.20.0'
  KUBECTL_VERSION: 'v1.28.0'
  HELM_VERSION: 'v3.13.0'

# Permissions for GitHub Container Registry
permissions:
  contents: read
  packages: write
  security-events: write
  actions: read

jobs:
  # Code quality and security checks
  code-quality:
    name: Code Quality & Security
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Clean Go module cache before restore
      run: |
        mkdir -p ~/.cache/go-build
        mkdir -p ~/go/pkg/mod
        # Clean up any problematic files that might cause tar extraction errors
        sudo find ~/.cache/go-build -name "*.tar*" -delete 2>/dev/null || true
        sudo find ~/go/pkg/mod -name "golang.org" -type d -exec rm -rf {} + 2>/dev/null || true
        sudo chmod -R 755 ~/.cache/go-build || true
        sudo chmod -R 755 ~/go/pkg/mod || true

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}-${{ github.run_id }}
        restore-keys: |
          ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}-
          ${{ runner.os }}-go-

    - name: Run go vet
      run: |
        find . -name "*.go" -path "*/vendor" -prune -o -name "*.go" -print0 | \
        xargs -0 -I {} dirname {} | sort -u | \
        xargs -I {} sh -c 'cd {} && go vet ./...'

    - name: Run staticcheck
      uses: dominikh/staticcheck-action@v1.3.0
      with:
        version: "2023.1.6"
        install-go: false

    - name: Install and run gosec security scan
      run: |
        go install github.com/securego/gosec/v2/cmd/gosec@latest

        # Create gosec configuration file
        cat > .gosec.json << 'EOF'
        {
          "severity": "medium",
          "confidence": "medium",
          "exclude-generated": true,
          "exclude-dirs": [
            "vendor",
            "node_modules",
            ".git",
            "tests/golden"
          ],
          "exclude-rules": [
            "G104",
            "G304"
          ],
          "include-rules": [
            "G101", "G102", "G103", "G106", "G107", "G108", "G109", "G110",
            "G201", "G202", "G203", "G204", "G301", "G302", "G303", "G305",
            "G401", "G402", "G403", "G404", "G501", "G502", "G503", "G504",
            "G505", "G601"
          ]
        }
        EOF

        # Run gosec with comprehensive scanning
        gosec -config=.gosec.json -fmt sarif -out gosec.sarif -stderr ./... || GOSEC_EXIT_CODE=$?

        # Also generate JSON and text reports for debugging
        gosec -config=.gosec.json -fmt json -out gosec.json ./... || true
        gosec -config=.gosec.json -fmt text -out gosec.txt ./... || true

        # Ensure valid SARIF file exists
        if [ ! -f gosec.sarif ] || [ ! -s gosec.sarif ]; then
          cat > gosec.sarif << 'EOF'
        {
          "version": "2.1.0",
          "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
          "runs": [
            {
              "tool": {
                "driver": {
                  "name": "gosec",
                  "version": "2.0.0",
                  "informationUri": "https://github.com/securego/gosec"
                }
              },
              "results": []
            }
          ]
        }
        EOF
        fi

        # Check if critical issues found and fail accordingly
        if [ -f gosec.json ] && [ -s gosec.json ]; then
          CRITICAL_COUNT=$(jq '[.Issues[] | select(.severity == "HIGH" or .confidence == "HIGH")] | length' gosec.json 2>/dev/null || echo "0")
          echo "Found $CRITICAL_COUNT high-severity security issues"
          if [ "$CRITICAL_COUNT" -gt "0" ]; then
            echo "::warning::Found $CRITICAL_COUNT high-severity security issues. Review gosec results."
          fi
        fi

    - name: Upload SARIF file
      if: always()
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: gosec.sarif
        category: 'gosec-ci'
        wait-for-processing: false
      continue-on-error: true

    - name: Run golangci-lint with security checks
      uses: golangci/golangci-lint-action@v3
      with:
        version: latest
        args: --timeout=10m --enable=gosec,gocritic,revive,staticcheck,unparam,unused,ineffassign,misspell,goconst,gocyclo,gofmt,goimports

    - name: Upload gosec artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: gosec-results
        path: |
          gosec.sarif
          gosec.json
          gosec.txt
          .gosec.json
        retention-days: 30

  # Unit tests for all components
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    strategy:
      matrix:
        component:
          - orchestrator
          - adapters/vnf-operator
          - o2-client
          - tn
          - cn-dms
          - ran-dms

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Setup Kubebuilder
      run: |
        KUBEBUILDER_VERSION=3.10.0
        os=$(go env GOOS)
        arch=$(go env GOARCH)
        curl -L https://github.com/kubernetes-sigs/kubebuilder/releases/download/v${KUBEBUILDER_VERSION}/kubebuilder_${KUBEBUILDER_VERSION}_${os}_${arch}.tar.gz | tar -xz -C /tmp/
        sudo mv /tmp/kubebuilder_${KUBEBUILDER_VERSION}_${os}_${arch} /usr/local/kubebuilder
        echo "/usr/local/kubebuilder/bin" >> $GITHUB_PATH

    - name: Validate component directory
      run: |
        # Check if component directory exists, if not look in deploy/docker/
        if [ ! -d "${{ matrix.component }}" ]; then
          if [ -d "deploy/docker/${{ matrix.component }}" ]; then
            echo "Component found in deploy/docker/${{ matrix.component }}"
            COMPONENT_PATH="deploy/docker/${{ matrix.component }}"
          else
            echo "ERROR: Component directory ${{ matrix.component }} not found!"
            exit 1
          fi
        else
          COMPONENT_PATH="${{ matrix.component }}"
        fi
        echo "COMPONENT_PATH=$COMPONENT_PATH" >> $GITHUB_ENV

    - name: Clean Go module cache before restore
      run: |
        mkdir -p ~/.cache/go-build
        mkdir -p ~/go/pkg/mod
        # Clean up any problematic files that might cause tar extraction errors
        sudo find ~/.cache/go-build -name "*.tar*" -delete 2>/dev/null || true
        sudo find ~/go/pkg/mod -name "golang.org" -type d -exec rm -rf {} + 2>/dev/null || true
        sudo chmod -R 755 ~/.cache/go-build || true
        sudo chmod -R 755 ~/go/pkg/mod || true

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ matrix.component }}-${{ hashFiles(format('{0}/**/go.sum', env.COMPONENT_PATH)) }}-${{ github.run_id }}
        restore-keys: |
          ${{ runner.os }}-go-${{ matrix.component }}-${{ hashFiles(format('{0}/**/go.sum', env.COMPONENT_PATH)) }}-
          ${{ runner.os }}-go-${{ matrix.component }}-

    - name: Install dependencies
      working-directory: ${{ env.COMPONENT_PATH }}
      run: |
        if [ -f go.mod ]; then
          # Disable workspace mode for individual module dependency installation
          GOWORK=off go mod download
        else
          echo "No go.mod found, skipping dependency installation for ${{ matrix.component }}"
        fi

    - name: Run unit tests
      working-directory: ${{ env.COMPONENT_PATH }}
      run: |
        if [ -f go.mod ]; then
          # Disable workspace mode for individual module tests
          GOWORK=off go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
        else
          echo "No go.mod found, skipping tests for ${{ matrix.component }}"
        fi

    - name: Generate coverage report
      working-directory: ${{ env.COMPONENT_PATH }}
      run: |
        if [ -f coverage.out ]; then
          go tool cover -html=coverage.out -o coverage.html
        else
          echo "No coverage.out found, skipping coverage report generation"
        fi

    - name: Upload coverage reports
      uses: actions/upload-artifact@v4
      if: env.COMPONENT_PATH != ''
      with:
        name: coverage-${{ matrix.component }}
        path: ${{ env.COMPONENT_PATH }}/coverage.*

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      if: env.COMPONENT_PATH != ''
      with:
        file: ${{ env.COMPONENT_PATH }}/coverage.out
        flags: ${{ matrix.component }}
        name: ${{ matrix.component }}

  # Build and push container images
  build-images:
    name: Build Container Images
    runs-on: ubuntu-latest
    needs: [code-quality, unit-tests]
    if: github.event_name != 'pull_request'

    strategy:
      matrix:
        component:
          - orchestrator
          - vnf-operator
          - o2-client
          - tn-manager
          - tn-agent
          - ran-dms
          - cn-dms

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.IMAGE_PREFIX }}/oran-${{ matrix.component }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Prepare Docker build context for tn-agent
      if: matrix.component == 'tn-agent'
      run: |
        # Special handling for tn-agent to ensure pkg/security is available
        if [ -d "deploy/docker/tn-agent" ]; then
          # Copy pkg/security to build context if needed
          if [ -d "pkg/security" ] && [ ! -d "deploy/docker/tn-agent/pkg/security" ]; then
            mkdir -p deploy/docker/tn-agent/pkg
            cp -r pkg/security deploy/docker/tn-agent/pkg/
          fi
          # Copy tn module files if not present
          if [ -d "tn" ] && [ ! -f "deploy/docker/tn-agent/tn/go.mod" ]; then
            cp -r tn deploy/docker/tn-agent/
          fi
        fi

    - name: Build and push image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: deploy/docker/${{ matrix.component }}/Dockerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          BUILDTIME=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
          VERSION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.version'] }}
          REVISION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.revision'] }}

  # Security scanning of container images
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: build-images
    if: github.event_name != 'pull_request'

    strategy:
      matrix:
        component:
          - orchestrator
          - vnf-operator
          - o2-client
          - tn-manager
          - tn-agent
          - ran-dms
          - cn-dms

    steps:
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.IMAGE_PREFIX }}/oran-${{ matrix.component }}:${{ github.sha }}
        format: 'sarif'
        output: 'trivy-results-${{ matrix.component }}.sarif'
        severity: 'CRITICAL,HIGH,MEDIUM'
        exit-code: '0'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results-${{ matrix.component }}.sarif'
        category: 'trivy-${{ matrix.component }}'
        wait-for-processing: false
      continue-on-error: true

    - name: Run Snyk to check for vulnerabilities
      uses: snyk/actions/docker@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        image: ${{ env.IMAGE_PREFIX }}/oran-${{ matrix.component }}:${{ github.sha }}
        args: --severity-threshold=high
      continue-on-error: true

  # Integration tests with Kind clusters
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: build-images
    if: github.event_name != 'pull_request' || contains(github.event.pull_request.labels.*.name, 'test-integration')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Install Kind
      run: |
        curl -Lo ./kind https://kind.sigs.k8s.io/dl/${{ env.KIND_VERSION }}/kind-linux-amd64
        chmod +x ./kind
        sudo mv ./kind /usr/local/bin/kind

    - name: Install kubectl
      run: |
        curl -LO "https://dl.k8s.io/release/${{ env.KUBECTL_VERSION }}/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/

    - name: Install Helm
      run: |
        curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
        chmod 700 get_helm.sh
        ./get_helm.sh --version ${{ env.HELM_VERSION }}

    - name: Free up disk space
      run: |
        sudo rm -rf /usr/share/dotnet
        sudo rm -rf /opt/ghc
        sudo rm -rf "/usr/local/share/boost"
        sudo rm -rf "$AGENT_TOOLSDIRECTORY"
        docker system prune -af

    - name: Set up clusters
      run: |
        chmod +x deploy/scripts/setup/setup-clusters.sh
        deploy/scripts/setup/setup-clusters.sh --clusters central,edge01

    - name: Load container images
      run: |
        docker pull ${{ env.IMAGE_PREFIX }}/oran-orchestrator:${{ github.sha }}
        docker pull ${{ env.IMAGE_PREFIX }}/oran-vnf-operator:${{ github.sha }}
        docker pull ${{ env.IMAGE_PREFIX }}/oran-o2-client:${{ github.sha }}

        kind load docker-image ${{ env.IMAGE_PREFIX }}/oran-orchestrator:${{ github.sha }} --name central
        kind load docker-image ${{ env.IMAGE_PREFIX }}/oran-vnf-operator:${{ github.sha }} --name central
        kind load docker-image ${{ env.IMAGE_PREFIX }}/oran-o2-client:${{ github.sha }} --name central

    - name: Deploy MANO components
      run: |
        export KUBECONFIG=/tmp/oran-mano-setup/multi-cluster-kubeconfig.yaml
        kubectl config use-context kind-central

        # Deploy using Helm charts
        helm install oran-orchestrator deploy/helm/charts/orchestrator \
          --set image.repository=${{ env.IMAGE_PREFIX }}/oran-orchestrator \
          --set image.tag=${{ github.sha }} \
          --namespace oran-mano --create-namespace --wait

    - name: Run integration tests
      run: |
        export KUBECONFIG=/tmp/oran-mano-setup/multi-cluster-kubeconfig.yaml
        chmod +x deploy/scripts/test/run_integration_tests.sh
        deploy/scripts/test/run_integration_tests.sh

    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: integration-test-results
        path: /test-results/

    - name: Cleanup clusters
      if: always()
      run: |
        kind delete cluster --name central || true
        kind delete cluster --name edge01 || true

  # Performance tests (only on manual trigger or specific labels)
  performance-tests:
    name: Performance Tests
    runs-on: ubuntu-latest
    needs: build-images
    if: |
      github.event.inputs.run_performance_tests == 'true' ||
      contains(github.event.pull_request.labels.*.name, 'test-performance') ||
      (github.event_name == 'push' && github.ref == 'refs/heads/main')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up infrastructure
      run: |
        # Install tools
        curl -Lo ./kind https://kind.sigs.k8s.io/dl/${{ env.KIND_VERSION }}/kind-linux-amd64
        chmod +x ./kind && sudo mv ./kind /usr/local/bin/kind

        curl -LO "https://dl.k8s.io/release/${{ env.KUBECTL_VERSION }}/bin/linux/amd64/kubectl"
        chmod +x kubectl && sudo mv kubectl /usr/local/bin/

        # Free up space for performance tests
        sudo rm -rf /usr/share/dotnet /opt/ghc /usr/local/share/boost "$AGENT_TOOLSDIRECTORY"
        docker system prune -af

    - name: Set up multi-cluster environment
      run: |
        chmod +x deploy/scripts/setup/setup-clusters.sh
        deploy/scripts/setup/setup-clusters.sh --with-monitoring

    - name: Deploy full system
      run: |
        export KUBECONFIG=/tmp/oran-mano-setup/multi-cluster-kubeconfig.yaml

        # Load all images to all clusters
        for cluster in central edge01 edge02 regional; do
          for component in orchestrator vnf-operator o2-client tn-manager tn-agent; do
            docker pull ${{ env.IMAGE_PREFIX }}/oran-$component:${{ github.sha }}
            kind load docker-image ${{ env.IMAGE_PREFIX }}/oran-$component:${{ github.sha }} --name $cluster
          done
        done

        # Deploy components
        chmod +x deploy/scripts/setup/deploy-mano.sh
        deploy/scripts/setup/deploy-mano.sh

    - name: Run performance tests
      run: |
        export KUBECONFIG=/tmp/oran-mano-setup/multi-cluster-kubeconfig.yaml
        chmod +x deploy/scripts/test/run_performance_tests.sh
        deploy/scripts/test/run_performance_tests.sh

    - name: Upload performance results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: performance-test-results
        path: /test-results/

    - name: Check performance targets
      run: |
        if [ -f /test-results/performance-test-report.json ]; then
          success_rate=$(jq -r '.summary.success_rate' /test-results/performance-test-report.json)
          if [ "$success_rate" -lt 80 ]; then
            echo "::error::Performance tests failed: only $success_rate% passed (target: 80%)"
            exit 1
          fi
        fi

    - name: Cleanup
      if: always()
      run: |
        for cluster in central edge01 edge02 regional; do
          kind delete cluster --name $cluster || true
        done

  # E2E tests (comprehensive system validation)
  e2e-tests:
    name: End-to-End Tests
    runs-on: ubuntu-latest
    needs: [integration-tests]
    if: |
      github.event.inputs.run_e2e_tests == 'true' ||
      contains(github.event.pull_request.labels.*.name, 'test-e2e') ||
      (github.event_name == 'push' && github.ref == 'refs/heads/main')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up complete test environment
      run: |
        # Install all required tools
        curl -Lo ./kind https://kind.sigs.k8s.io/dl/${{ env.KIND_VERSION }}/kind-linux-amd64
        chmod +x ./kind && sudo mv ./kind /usr/local/bin/kind

        curl -LO "https://dl.k8s.io/release/${{ env.KUBECTL_VERSION }}/bin/linux/amd64/kubectl"
        chmod +x kubectl && sudo mv kubectl /usr/local/bin/

        curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
        chmod 700 get_helm.sh && ./get_helm.sh --version ${{ env.HELM_VERSION }}

    - name: Run E2E test suite
      run: |
        chmod +x deploy/scripts/test/run_e2e_tests.sh
        deploy/scripts/test/run_e2e_tests.sh

    - name: Upload E2E results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: e2e-test-results
        path: /test-results/

  # Deployment to staging (on main branch)
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [integration-tests, security-scan]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: staging

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl
      run: |
        echo "${{ secrets.STAGING_KUBECONFIG }}" | base64 -d > /tmp/kubeconfig
        echo "KUBECONFIG=/tmp/kubeconfig" >> $GITHUB_ENV

    - name: Deploy to staging
      run: |
        helm upgrade --install oran-mano deploy/helm/charts/orchestrator \
          --set image.repository=${{ env.IMAGE_PREFIX }}/oran-orchestrator \
          --set image.tag=${{ github.sha }} \
          --namespace oran-staging --create-namespace --wait

    - name: Run smoke tests
      run: |
        kubectl wait --for=condition=Available deployment/oran-orchestrator \
          -n oran-staging --timeout=300s

        # Basic health check
        kubectl port-forward -n oran-staging service/oran-orchestrator 8080:8080 &
        sleep 5
        curl -f http://localhost:8080/health

  # Release workflow (on tags)
  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [performance-tests, e2e-tests]
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Generate changelog
      id: changelog
      run: |
        echo "## Changes" > CHANGELOG.md
        git log --pretty=format:"* %s" $(git describe --tags --abbrev=0 HEAD^)..HEAD >> CHANGELOG.md

    - name: Create Release
      uses: softprops/action-gh-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref_name }}
        release_name: O-RAN Intent-MANO ${{ github.ref_name }}
        body_path: CHANGELOG.md
        draft: false
        prerelease: false

  # Notification on workflow completion
  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [code-quality, unit-tests, build-images, integration-tests]
    if: always()

    steps:
    - name: Notify on success
      if: needs.code-quality.result == 'success' && needs.unit-tests.result == 'success' && needs.build-images.result == 'success' && needs.integration-tests.result == 'success'
      run: |
        echo "All CI checks passed successfully!"

    - name: Notify on failure
      if: needs.code-quality.result == 'failure' || needs.unit-tests.result == 'failure' || needs.build-images.result == 'failure' || needs.integration-tests.result == 'failure'
      run: |
        echo "ERROR: Some CI checks failed. Please review the logs."
        exit 1