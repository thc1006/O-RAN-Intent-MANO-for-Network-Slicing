---
# Pod Security Standards ValidatingAdmissionWebhook
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingAdmissionWebhook
metadata:
  name: pod-security-standards-enforcer
webhooks:
- name: pod-security.oran-mano.io
  clientConfig:
    service:
      name: pod-security-webhook
      namespace: oran-mano
      path: "/validate-security"
  rules:
  - operations: ["CREATE", "UPDATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]
  - operations: ["CREATE", "UPDATE"]
    apiGroups: ["apps"]
    apiVersions: ["v1"]
    resources: ["deployments", "replicasets", "daemonsets", "statefulsets"]
  namespaceSelector:
    matchLabels:
      pod-security.kubernetes.io/enforce: restricted
  admissionReviewVersions: ["v1", "v1beta1"]
  sideEffects: None
  failurePolicy: Fail
---
# Pod Security Standards enforcement via admission controller
apiVersion: v1
kind: ConfigMap
metadata:
  name: pod-security-config
  namespace: oran-mano
data:
  policy.yaml: |
    apiVersion: security.k8s.io/v1
    kind: PodSecurityConfiguration
    defaults:
      enforce: "restricted"
      enforce-version: "latest"
      audit: "restricted"
      audit-version: "latest"
      warn: "restricted"
      warn-version: "latest"
    exemptions:
      usernames: []
      runtimeClasses: []
      namespaces: ["kube-system", "kube-public", "kube-node-lease"]
---
# Network Policy to deny all traffic by default (more restrictive)
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all-default
  namespace: oran-mano
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
  # This policy denies all traffic by default
  # Specific policies will override this for required communication
---
# Security Context Constraints (OpenShift) / Pod Security Standards
apiVersion: v1
kind: LimitRange
metadata:
  name: oran-mano-security-limits
  namespace: oran-mano
spec:
  limits:
  - default:
      cpu: "100m"
      memory: "128Mi"
      ephemeral-storage: "1Gi"
    defaultRequest:
      cpu: "50m"
      memory: "64Mi"
      ephemeral-storage: "512Mi"
    max:
      cpu: "2000m"
      memory: "2Gi"
      ephemeral-storage: "10Gi"
    min:
      cpu: "10m"
      memory: "32Mi"
      ephemeral-storage: "256Mi"
    type: Container
  - default:
      cpu: "500m"
      memory: "512Mi"
      ephemeral-storage: "2Gi"
    defaultRequest:
      cpu: "100m"
      memory: "128Mi"
      ephemeral-storage: "1Gi"
    max:
      cpu: "4000m"
      memory: "4Gi"
      ephemeral-storage: "20Gi"
    min:
      cpu: "50m"
      memory: "64Mi"
      ephemeral-storage: "512Mi"
    type: Pod
---
# Resource Quota for namespace
apiVersion: v1
kind: ResourceQuota
metadata:
  name: oran-mano-resource-quota
  namespace: oran-mano
spec:
  hard:
    requests.cpu: "2000m"
    requests.memory: "4Gi"
    requests.ephemeral-storage: "10Gi"
    limits.cpu: "8000m"
    limits.memory: "16Gi"
    limits.ephemeral-storage: "50Gi"
    persistentvolumeclaims: "10"
    services: "20"
    secrets: "20"
    configmaps: "20"
    pods: "20"
---
# CIS Kubernetes Benchmark compliance ValidatingAdmissionWebhook
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingAdmissionWebhook
metadata:
  name: cis-compliance-validator
webhooks:
- name: cis-compliance.oran-mano.io
  clientConfig:
    service:
      name: cis-compliance-webhook
      namespace: oran-mano
      path: "/validate-cis"
  rules:
  - operations: ["CREATE", "UPDATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods", "services", "configmaps", "secrets"]
  - operations: ["CREATE", "UPDATE"]
    apiGroups: ["apps"]
    apiVersions: ["v1"]
    resources: ["deployments", "replicasets", "daemonsets", "statefulsets"]
  - operations: ["CREATE", "UPDATE"]
    apiGroups: ["rbac.authorization.k8s.io"]
    apiVersions: ["v1"]
    resources: ["roles", "rolebindings", "clusterroles", "clusterrolebindings"]
  namespaceSelector:
    matchLabels:
      security-scan: "enabled"
  admissionReviewVersions: ["v1", "v1beta1"]
  sideEffects: None
  failurePolicy: Fail
---
# Secure Base Image Policy (OPA Gatekeeper)
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredbaseimage
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredBaseImage
      validation:
        type: object
        properties:
          allowedImages:
            type: array
            items:
              type: string
          allowedRegistries:
            type: array
            items:
              type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredbaseimage

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not image_allowed(container.image)
          msg := sprintf("Container '%v' uses disallowed image '%v'. Must use approved base images or registries.", [container.name, container.image])
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.initContainers[_]
          not image_allowed(container.image)
          msg := sprintf("Init container '%v' uses disallowed image '%v'. Must use approved base images or registries.", [container.name, container.image])
        }

        image_allowed(image) {
          allowed_image := input.parameters.allowedImages[_]
          startswith(image, allowed_image)
        }

        image_allowed(image) {
          allowed_registry := input.parameters.allowedRegistries[_]
          startswith(image, allowed_registry)
        }
---
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequiredBaseImage
metadata:
  name: secure-base-images-only
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "DaemonSet", "StatefulSet"]
      - apiGroups: [""]
        kinds: ["Pod"]
    namespaces: ["oran-mano", "oran-edge", "oran-core"]
  parameters:
    allowedImages:
      - "ghcr.io/oran-mano/"
      - "gcr.io/distroless/"
      - "cgr.dev/chainguard/"
    allowedRegistries:
      - "ghcr.io/oran-mano/"
      - "gcr.io/distroless/"
      - "cgr.dev/chainguard/"
      - "registry.access.redhat.com/ubi8/ubi-minimal"
---
# Security Context Constraint Template
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredsecuritycontext
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredSecurityContext
      validation:
        type: object
        properties:
          runAsNonRoot:
            type: boolean
          readOnlyRootFilesystem:
            type: boolean
          allowPrivilegeEscalation:
            type: boolean
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredsecuritycontext

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.runAsNonRoot == input.parameters.runAsNonRoot
          msg := sprintf("Container '%v' must have runAsNonRoot set to %v", [container.name, input.parameters.runAsNonRoot])
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.readOnlyRootFilesystem == input.parameters.readOnlyRootFilesystem
          msg := sprintf("Container '%v' must have readOnlyRootFilesystem set to %v", [container.name, input.parameters.readOnlyRootFilesystem])
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.allowPrivilegeEscalation == input.parameters.allowPrivilegeEscalation
          msg := sprintf("Container '%v' must have allowPrivilegeEscalation set to %v", [container.name, input.parameters.allowPrivilegeEscalation])
        }
---
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequiredSecurityContext
metadata:
  name: enforce-security-context
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "DaemonSet", "StatefulSet"]
      - apiGroups: [""]
        kinds: ["Pod"]
    namespaces: ["oran-mano", "oran-edge", "oran-core"]
  parameters:
    runAsNonRoot: true
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false