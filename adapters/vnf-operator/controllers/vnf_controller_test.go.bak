package controllers

import (
	"context"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"

	manov1alpha1 "github.com/o-ran/intent-mano/adapters/vnf-operator/api/v1alpha1"
	"github.com/o-ran/intent-mano/adapters/vnf-operator/pkg/dms"
	"github.com/o-ran/intent-mano/adapters/vnf-operator/pkg/gitops"
	"github.com/o-ran/intent-mano/adapters/vnf-operator/pkg/translator"
)

var _ = Describe("VNF Controller", func() {
	Context("When reconciling a VNF", func() {
		const (
			vnfName      = "test-vnf"
			vnfNamespace = "default"
			timeout      = time.Second * 10
			interval     = time.Millisecond * 250
		)

		BeforeEach(func() {
			// Initialize mock clients for the reconciler
			vnfReconciler := &VNFReconciler{
				Client:          k8sClient,
				Scheme:          k8sClient.Scheme(),
				PorchTranslator: translator.NewPorchTranslator(),
				DMSClient:       dms.NewMockDMSClient(),
				GitOpsClient:    gitops.NewMockGitOpsClient(),
			}
			_ = vnfReconciler
		})

		AfterEach(func() {
			// Cleanup VNF resources
			vnf := &manov1alpha1.VNF{}
			err := k8sClient.Get(context.Background(),
				types.NamespacedName{Name: vnfName, Namespace: vnfNamespace}, vnf)
			if err == nil {
				_ = k8sClient.Delete(context.Background(), vnf)
			}
		})

		It("Should create VNF with RAN type successfully", func() {
			ctx := context.Background()

			// Create a RAN VNF
			vnf := &manov1alpha1.VNF{
				TypeMeta: metav1.TypeMeta{
					APIVersion: "mano.oran.io/v1alpha1",
					Kind:       "VNF",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      vnfName,
					Namespace: vnfNamespace,
				},
				Spec: manov1alpha1.VNFSpec{
					Type:    "RAN",
					Version: "1.0.0",
					Placement: manov1alpha1.PlacementPolicy{
						CloudType:  "edge",
						MaxLatency: 5,
					},
					Resources: manov1alpha1.ResourceRequirements{
						CPU:    "500m",
						Memory: "1Gi",
					},
					QoS: manov1alpha1.QoSParameters{
						Bandwidth: 5.0,
						Latency:   1.0,
					},
					TargetClusters: []string{"edge01", "edge02"},
				},
			}

			Expect(k8sClient.Create(ctx, vnf)).Should(Succeed())

			// Wait for VNF to be created
			createdVNF := &manov1alpha1.VNF{}
			Eventually(func() bool {
				err := k8sClient.Get(ctx,
					types.NamespacedName{Name: vnfName, Namespace: vnfNamespace},
					createdVNF)
				return err == nil
			}, timeout, interval).Should(BeTrue())

			// Verify VNF spec
			Expect(createdVNF.Spec.Type).Should(Equal("RAN"))
			Expect(createdVNF.Spec.QoS.Bandwidth).Should(Equal(float32(5.0)))
			Expect(createdVNF.Spec.QoS.Latency).Should(Equal(float32(1.0)))
		})

		It("Should create VNF with CN type successfully", func() {
			ctx := context.Background()

			// Create a CN VNF
			vnf := &manov1alpha1.VNF{
				TypeMeta: metav1.TypeMeta{
					APIVersion: "mano.oran.io/v1alpha1",
					Kind:       "VNF",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      vnfName + "-cn",
					Namespace: vnfNamespace,
				},
				Spec: manov1alpha1.VNFSpec{
					Type:    "CN",
					Version: "2.0.0",
					Placement: manov1alpha1.PlacementPolicy{
						CloudType:  "regional",
						MaxLatency: 10,
					},
					Resources: manov1alpha1.ResourceRequirements{
						CPU:    "1",
						Memory: "2Gi",
					},
					QoS: manov1alpha1.QoSParameters{
						Bandwidth: 3.0,
						Latency:   9.0,
					},
					TargetClusters: []string{"regional"},
				},
			}

			Expect(k8sClient.Create(ctx, vnf)).Should(Succeed())

			// Verify creation
			createdVNF := &manov1alpha1.VNF{}
			Eventually(func() bool {
				err := k8sClient.Get(ctx,
					types.NamespacedName{Name: vnfName + "-cn", Namespace: vnfNamespace},
					createdVNF)
				return err == nil
			}, timeout, interval).Should(BeTrue())

			Expect(createdVNF.Spec.Type).Should(Equal("CN"))
			Expect(createdVNF.Spec.Placement.CloudType).Should(Equal("regional"))
		})

		It("Should validate QoS parameters", func() {
			ctx := context.Background()

			// Create VNF with invalid QoS parameters
			vnf := &manov1alpha1.VNF{
				TypeMeta: metav1.TypeMeta{
					APIVersion: "mano.oran.io/v1alpha1",
					Kind:       "VNF",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      vnfName + "-invalid",
					Namespace: vnfNamespace,
				},
				Spec: manov1alpha1.VNFSpec{
					Type:    "RAN",
					Version: "1.0.0",
					Placement: manov1alpha1.PlacementPolicy{
						CloudType: "edge",
					},
					Resources: manov1alpha1.ResourceRequirements{
						CPU:    "500m",
						Memory: "1Gi",
					},
					QoS: manov1alpha1.QoSParameters{
						Bandwidth: 10.0, // Invalid: > 5
						Latency:   0.5,  // Invalid: < 1
					},
				},
			}

			Expect(k8sClient.Create(ctx, vnf)).Should(Succeed())

			// The controller should mark it as failed during reconciliation
			// This test verifies the VNF is created but validation would fail in reconciliation
		})

		It("Should handle VNF deletion with finalizer", func() {
			ctx := context.Background()

			// Create a VNF
			vnf := &manov1alpha1.VNF{
				TypeMeta: metav1.TypeMeta{
					APIVersion: "mano.oran.io/v1alpha1",
					Kind:       "VNF",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      vnfName + "-delete",
					Namespace: vnfNamespace,
				},
				Spec: manov1alpha1.VNFSpec{
					Type:    "TN",
					Version: "1.0.0",
					Placement: manov1alpha1.PlacementPolicy{
						CloudType: "edge",
					},
					Resources: manov1alpha1.ResourceRequirements{
						CPU:    "200m",
						Memory: "512Mi",
					},
					QoS: manov1alpha1.QoSParameters{
						Bandwidth: 1.0,
						Latency:   1.0,
					},
				},
			}

			Expect(k8sClient.Create(ctx, vnf)).Should(Succeed())

			// Wait for creation
			createdVNF := &manov1alpha1.VNF{}
			Eventually(func() bool {
				err := k8sClient.Get(ctx,
					types.NamespacedName{Name: vnfName + "-delete", Namespace: vnfNamespace},
					createdVNF)
				return err == nil
			}, timeout, interval).Should(BeTrue())

			// Delete the VNF
			Expect(k8sClient.Delete(ctx, createdVNF)).Should(Succeed())

			// Verify deletion
			Eventually(func() bool {
				err := k8sClient.Get(ctx,
					types.NamespacedName{Name: vnfName + "-delete", Namespace: vnfNamespace},
					&manov1alpha1.VNF{})
				return errors.IsNotFound(err)
			}, timeout, interval).Should(BeTrue())
		})
	})
})