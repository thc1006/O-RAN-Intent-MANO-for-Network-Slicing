---
apiVersion: v1
kind: Pod
metadata:
  name: "oran-monitoring-test"
  namespace: oran-monitoring
  labels:
    app.kubernetes.io/name: monitoring-test
    app.kubernetes.io/component: test
    app.kubernetes.io/part-of: oran-intent-mano
    app.kubernetes.io/managed-by: helm
  annotations:
    "helm.sh/hook": test
    "helm.sh/hook-weight": "1"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  restartPolicy: Never
  securityContext:
    runAsNonRoot: true
    runAsUser: 65534
    runAsGroup: 65534
    fsGroup: 65534
    seccompProfile:
      type: RuntimeDefault
  containers:
  - name: monitoring-test
    image: curlimages/curl:8.4.0
    imagePullPolicy: IfNotPresent
    securityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 65534
      runAsGroup: 65534
    env:
    - name: PROMETHEUS_URL
      value: "http://prometheus.oran-monitoring.svc.cluster.local:9090"
    - name: GRAFANA_URL
      value: "http://grafana.oran-monitoring.svc.cluster.local:3000"
    - name: ALERTMANAGER_URL
      value: "http://alertmanager.oran-monitoring.svc.cluster.local:9093"
    - name: GRAFANA_USER
      value: "admin"
    - name: GRAFANA_PASSWORD
      valueFrom:
        secretKeyRef:
          name: grafana-admin-credentials
          key: password
          optional: true
    command:
    - /bin/sh
    - -c
    - |
      set -e

      # Colors for output
      RED='\033[0;31m'
      GREEN='\033[0;32m'
      YELLOW='\033[1;33m'
      BLUE='\033[0;34m'
      NC='\033[0m'

      log_info() {
          echo -e "${BLUE}[INFO]${NC} $1"
      }

      log_success() {
          echo -e "${GREEN}[SUCCESS]${NC} $1"
      }

      log_warning() {
          echo -e "${YELLOW}[WARNING]${NC} $1"
      }

      log_error() {
          echo -e "${RED}[ERROR]${NC} $1"
      }

      # Test counters
      total_tests=0
      passed_tests=0
      failed_tests=0

      run_test() {
          local test_name="$1"
          local test_command="$2"

          total_tests=$((total_tests + 1))
          log_info "Running test: $test_name"

          if eval "$test_command"; then
              log_success "✓ $test_name"
              passed_tests=$((passed_tests + 1))
              return 0
          else
              log_error "✗ $test_name"
              failed_tests=$((failed_tests + 1))
              return 1
          fi
      }

      # Test 1: Prometheus Health Check
      test_prometheus_health() {
          local response_code
          response_code=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$PROMETHEUS_URL/-/healthy")

          if [[ "$response_code" == "200" ]]; then
              log_info "  Prometheus health endpoint returned: $response_code"
              return 0
          else
              log_error "  Prometheus health endpoint returned: $response_code"
              return 1
          fi
      }

      # Test 2: Prometheus API Query
      test_prometheus_query() {
          local response
          response=$(curl -s --max-time 30 "$PROMETHEUS_URL/api/v1/query?query=up")

          local status
          status=$(echo "$response" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)

          if [[ "$status" == "success" ]]; then
              local result_count
              result_count=$(echo "$response" | grep -o '"result":\[[^]]*\]' | grep -o '\[.*\]' | grep -o ',' | wc -l)
              result_count=$((result_count + 1))
              log_info "  Prometheus query returned $result_count results"
              return 0
          else
              log_error "  Prometheus query failed with status: $status"
              return 1
          fi
      }

      # Test 3: Prometheus Targets
      test_prometheus_targets() {
          local response
          response=$(curl -s --max-time 30 "$PROMETHEUS_URL/api/v1/targets")

          local status
          status=$(echo "$response" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)

          if [[ "$status" == "success" ]]; then
              # Count UP targets
              local up_count
              up_count=$(echo "$response" | grep -o '"health":"up"' | wc -l)
              log_info "  Found $up_count healthy targets"

              if [[ $up_count -gt 0 ]]; then
                  return 0
              else
                  log_error "  No healthy targets found"
                  return 1
              fi
          else
              log_error "  Prometheus targets query failed"
              return 1
          fi
      }

      # Test 4: Prometheus Rules
      test_prometheus_rules() {
          local response
          response=$(curl -s --max-time 30 "$PROMETHEUS_URL/api/v1/rules")

          local status
          status=$(echo "$response" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)

          if [[ "$status" == "success" ]]; then
              # Count rules (approximate)
              local rules_count
              rules_count=$(echo "$response" | grep -o '"name":' | wc -l)
              log_info "  Found $rules_count rules"

              if [[ $rules_count -gt 0 ]]; then
                  return 0
              else
                  log_warning "  No rules found"
                  return 0  # Not critical for basic functionality
              fi
          else
              log_error "  Prometheus rules query failed"
              return 1
          fi
      }

      # Test 5: Grafana Health Check
      test_grafana_health() {
          local response_code
          response_code=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$GRAFANA_URL/api/health")

          if [[ "$response_code" == "200" ]]; then
              log_info "  Grafana health endpoint returned: $response_code"
              return 0
          else
              log_error "  Grafana health endpoint returned: $response_code"
              return 1
          fi
      }

      # Test 6: Grafana Login and API
      test_grafana_api() {
          local grafana_password="${GRAFANA_PASSWORD:-admin}"
          local response

          response=$(curl -s --max-time 30 -u "$GRAFANA_USER:$grafana_password" "$GRAFANA_URL/api/org")

          # Check if response contains org info
          if echo "$response" | grep -q '"name":'; then
              log_info "  Grafana API authentication successful"
              return 0
          else
              log_error "  Grafana API authentication failed"
              return 1
          fi
      }

      # Test 7: Grafana Data Sources
      test_grafana_datasources() {
          local grafana_password="${GRAFANA_PASSWORD:-admin}"
          local response

          response=$(curl -s --max-time 30 -u "$GRAFANA_USER:$grafana_password" "$GRAFANA_URL/api/datasources")

          # Check if response is an array and contains data sources
          if echo "$response" | grep -q '\['; then
              local ds_count
              ds_count=$(echo "$response" | grep -o '"name":' | wc -l)
              log_info "  Found $ds_count data sources"

              if [[ $ds_count -gt 0 ]]; then
                  return 0
              else
                  log_warning "  No data sources configured"
                  return 1
              fi
          else
              log_error "  Failed to retrieve data sources"
              return 1
          fi
      }

      # Test 8: Grafana Dashboards
      test_grafana_dashboards() {
          local grafana_password="${GRAFANA_PASSWORD:-admin}"
          local response

          response=$(curl -s --max-time 30 -u "$GRAFANA_USER:$grafana_password" "$GRAFANA_URL/api/search?type=dash-db")

          # Check if response is an array
          if echo "$response" | grep -q '\['; then
              local dashboard_count
              dashboard_count=$(echo "$response" | grep -o '"title":' | wc -l)
              log_info "  Found $dashboard_count dashboards"

              if [[ $dashboard_count -gt 0 ]]; then
                  return 0
              else
                  log_warning "  No dashboards found"
                  return 0  # Not critical for basic functionality
              fi
          else
              log_error "  Failed to retrieve dashboards"
              return 1
          fi
      }

      # Test 9: AlertManager Health Check
      test_alertmanager_health() {
          local response_code
          response_code=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$ALERTMANAGER_URL/api/v2/status")

          if [[ "$response_code" == "200" ]]; then
              log_info "  AlertManager status endpoint returned: $response_code"
              return 0
          else
              log_error "  AlertManager status endpoint returned: $response_code"
              return 1
          fi
      }

      # Test 10: AlertManager Alerts
      test_alertmanager_alerts() {
          local response
          response=$(curl -s --max-time 30 "$ALERTMANAGER_URL/api/v2/alerts")

          # Check if response is an array
          if echo "$response" | grep -q '\['; then
              local alert_count
              alert_count=$(echo "$response" | grep -o '"alertname":' | wc -l)
              log_info "  Found $alert_count active alerts"
              return 0
          else
              log_error "  Failed to retrieve alerts"
              return 1
          fi
      }

      # Test 11: ServiceMonitor Discovery (check if O-RAN services are discovered)
      test_servicemonitor_discovery() {
          local response
          response=$(curl -s --max-time 30 "$PROMETHEUS_URL/api/v1/targets")

          # Look for O-RAN targets
          local oran_targets
          oran_targets=$(echo "$response" | grep -o '"job":"oran-[^"]*"' | wc -l)

          if [[ $oran_targets -gt 0 ]]; then
              log_info "  Found $oran_targets O-RAN service targets"
              return 0
          else
              log_warning "  No O-RAN service targets found"
              return 0  # Not critical if O-RAN services aren't deployed yet
          fi
      }

      # Test 12: End-to-End Query Test
      test_e2e_query() {
          local grafana_password="${GRAFANA_PASSWORD:-admin}"

          # Get Prometheus data source ID
          local datasources
          datasources=$(curl -s --max-time 30 -u "$GRAFANA_USER:$grafana_password" "$GRAFANA_URL/api/datasources")

          local prometheus_id
          prometheus_id=$(echo "$datasources" | grep -A 5 -B 5 '"type":"prometheus"' | grep '"id":' | head -1 | grep -o '[0-9]*')

          if [[ -n "$prometheus_id" ]]; then
              # Test data source connectivity
              local test_response
              test_response=$(curl -s --max-time 30 -u "$GRAFANA_USER:$grafana_password" \
                             -X POST \
                             -H "Content-Type: application/json" \
                             -d '{}' \
                             "$GRAFANA_URL/api/datasources/$prometheus_id/health")

              if echo "$test_response" | grep -q '"status":"success"'; then
                  log_info "  End-to-end query test successful"
                  return 0
              else
                  log_error "  End-to-end query test failed"
                  return 1
              fi
          else
              log_error "  Could not find Prometheus data source ID"
              return 1
          fi
      }

      # Main test execution
      log_info "=== O-RAN Monitoring Stack Helm Tests ==="
      log_info "Starting comprehensive monitoring stack validation..."
      echo

      # Run all tests
      run_test "Prometheus Health Check" "test_prometheus_health"
      run_test "Prometheus API Query" "test_prometheus_query"
      run_test "Prometheus Targets" "test_prometheus_targets"
      run_test "Prometheus Rules" "test_prometheus_rules"
      run_test "Grafana Health Check" "test_grafana_health"
      run_test "Grafana API Authentication" "test_grafana_api"
      run_test "Grafana Data Sources" "test_grafana_datasources"
      run_test "Grafana Dashboards" "test_grafana_dashboards"
      run_test "AlertManager Health Check" "test_alertmanager_health"
      run_test "AlertManager Alerts" "test_alertmanager_alerts"
      run_test "ServiceMonitor Discovery" "test_servicemonitor_discovery"
      run_test "End-to-End Query Test" "test_e2e_query"

      # Test results summary
      echo
      log_info "=== Test Results Summary ==="
      log_info "Total tests: $total_tests"
      log_success "Passed: $passed_tests"

      if [[ $failed_tests -gt 0 ]]; then
          log_error "Failed: $failed_tests"
      else
          log_success "Failed: $failed_tests"
      fi

      success_rate=$((passed_tests * 100 / total_tests))
      log_info "Success rate: ${success_rate}%"

      # Determine overall status
      if [[ $failed_tests -eq 0 ]]; then
          log_success "=== All monitoring stack tests passed! ==="
          exit 0
      elif [[ $success_rate -ge 80 ]]; then
          log_warning "=== Most tests passed (${success_rate}%), but some failures detected ==="
          exit 0
      else
          log_error "=== Significant test failures detected (${success_rate}% success rate) ==="
          exit 1
      fi
    resources:
      limits:
        cpu: 100m
        memory: 128Mi
      requests:
        cpu: 50m
        memory: 64Mi
    volumeMounts:
    - name: tmp
      mountPath: /tmp
  volumes:
  - name: tmp
    emptyDir: {}
  nodeSelector:
    kubernetes.io/os: linux
  tolerations:
  - effect: NoSchedule
    operator: Exists
---
# Test for O-RAN specific metrics and functionality
apiVersion: v1
kind: Pod
metadata:
  name: "oran-monitoring-advanced-test"
  namespace: oran-monitoring
  labels:
    app.kubernetes.io/name: monitoring-advanced-test
    app.kubernetes.io/component: test
    app.kubernetes.io/part-of: oran-intent-mano
    app.kubernetes.io/managed-by: helm
  annotations:
    "helm.sh/hook": test
    "helm.sh/hook-weight": "2"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  restartPolicy: Never
  securityContext:
    runAsNonRoot: true
    runAsUser: 65534
    runAsGroup: 65534
    fsGroup: 65534
    seccompProfile:
      type: RuntimeDefault
  containers:
  - name: advanced-test
    image: curlimages/curl:8.4.0
    imagePullPolicy: IfNotPresent
    securityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 65534
      runAsGroup: 65534
    env:
    - name: PROMETHEUS_URL
      value: "http://prometheus.oran-monitoring.svc.cluster.local:9090"
    command:
    - /bin/sh
    - -c
    - |
      set -e

      # Colors for output
      RED='\033[0;31m'
      GREEN='\033[0;32m'
      YELLOW='\033[1;33m'
      BLUE='\033[0;34m'
      NC='\033[0m'

      log_info() {
          echo -e "${BLUE}[INFO]${NC} $1"
      }

      log_success() {
          echo -e "${GREEN}[SUCCESS]${NC} $1"
      }

      log_warning() {
          echo -e "${YELLOW}[WARNING]${NC} $1"
      }

      log_error() {
          echo -e "${RED}[ERROR]${NC} $1"
      }

      log_info "=== O-RAN Monitoring Advanced Tests ==="
      log_info "Testing O-RAN specific functionality and performance..."
      echo

      # Test 1: O-RAN Metrics Presence
      log_info "Testing O-RAN specific metrics..."

      oran_metrics=(
          "oran_intent_processing_duration_seconds"
          "oran_slice_deployment_duration_seconds"
          "oran_vnf_placement_total"
          "oran_network_slice_throughput_mbps"
          "oran_ping_rtt_milliseconds"
      )

      found_metrics=0
      for metric in "${oran_metrics[@]}"; do
          response=$(curl -s --max-time 30 "$PROMETHEUS_URL/api/v1/query?query=$metric")
          status=$(echo "$response" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)

          if [[ "$status" == "success" ]]; then
              result_count=$(echo "$response" | grep -o '"result":\[[^]]*\]' | wc -l)
              if [[ $result_count -gt 0 ]]; then
                  log_success "  ✓ Found metric: $metric"
                  found_metrics=$((found_metrics + 1))
              else
                  log_warning "  ○ Metric defined but no data: $metric"
              fi
          else
              log_warning "  ○ Metric not found: $metric"
          fi
      done

      if [[ $found_metrics -gt 0 ]]; then
          log_success "Found $found_metrics O-RAN specific metrics"
      else
          log_warning "No O-RAN specific metrics found (services may not be deployed)"
      fi

      # Test 2: Recording Rules Evaluation
      log_info "Testing O-RAN recording rules..."

      response=$(curl -s --max-time 30 "$PROMETHEUS_URL/api/v1/rules")
      status=$(echo "$response" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)

      if [[ "$status" == "success" ]]; then
          oran_rules_count=$(echo "$response" | grep -o '"name":"oran:' | wc -l)
          if [[ $oran_rules_count -gt 0 ]]; then
              log_success "Found $oran_rules_count O-RAN recording rules"
          else
              log_warning "No O-RAN recording rules found"
          fi
      else
          log_error "Failed to query recording rules"
      fi

      # Test 3: Performance Validation
      log_info "Testing query performance..."

      test_queries=(
          "up"
          "rate(prometheus_http_requests_total[5m])"
          "histogram_quantile(0.95, rate(prometheus_http_request_duration_seconds_bucket[5m]))"
      )

      for query in "${test_queries[@]}"; do
          start_time=$(date +%s%3N)
          response=$(curl -s --max-time 30 "$PROMETHEUS_URL/api/v1/query?query=$query")
          end_time=$(date +%s%3N)

          duration=$((end_time - start_time))

          if [[ $duration -lt 1000 ]]; then
              log_success "  ✓ Query performed in ${duration}ms: $query"
          else
              log_warning "  ⚠ Slow query (${duration}ms): $query"
          fi
      done

      # Test 4: Cardinality Check
      log_info "Testing metrics cardinality..."

      response=$(curl -s --max-time 30 "$PROMETHEUS_URL/api/v1/query?query=prometheus_tsdb_head_series")
      status=$(echo "$response" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)

      if [[ "$status" == "success" ]]; then
          # Extract series count (simplified)
          series_info=$(echo "$response" | grep -o '"value":\[[^]]*\]')
          if [[ -n "$series_info" ]]; then
              log_success "  ✓ Successfully retrieved series count information"
          fi
      fi

      # Test 5: Alert Rules Validation
      log_info "Testing alert rules configuration..."

      response=$(curl -s --max-time 30 "$PROMETHEUS_URL/api/v1/rules")
      status=$(echo "$response" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)

      if [[ "$status" == "success" ]]; then
          total_rules=$(echo "$response" | grep -o '"name":' | wc -l)
          alert_rules=$(echo "$response" | grep -o '"type":"alerting"' | wc -l)
          recording_rules=$(echo "$response" | grep -o '"type":"recording"' | wc -l)

          log_info "  Total rules: $total_rules"
          log_info "  Alert rules: $alert_rules"
          log_info "  Recording rules: $recording_rules"

          if [[ $total_rules -gt 0 ]]; then
              log_success "Alert rules are properly configured"
          else
              log_warning "No alert rules found"
          fi
      fi

      # Test 6: Data Retention Test
      log_info "Testing data retention..."

      # Query data from 1 hour ago
      end_time=$(date +%s)
      start_time=$((end_time - 3600))

      response=$(curl -s --max-time 30 "$PROMETHEUS_URL/api/v1/query_range?query=up&start=$start_time&end=$end_time&step=60")
      status=$(echo "$response" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)

      if [[ "$status" == "success" ]]; then
          # Check if we have historical data
          if echo "$response" | grep -q '"values":'; then
              log_success "  ✓ Historical data available (1 hour retention verified)"
          else
              log_warning "  ○ Limited historical data available"
          fi
      else
          log_warning "  ○ Could not verify data retention"
      fi

      log_info "=== Advanced tests completed ==="
      log_success "O-RAN monitoring stack advanced validation finished"
    resources:
      limits:
        cpu: 100m
        memory: 128Mi
      requests:
        cpu: 50m
        memory: 64Mi
    volumeMounts:
    - name: tmp
      mountPath: /tmp
  volumes:
  - name: tmp
    emptyDir: {}
  nodeSelector:
    kubernetes.io/os: linux
  tolerations:
  - effect: NoSchedule
    operator: Exists
---
# ConfigMap with test utilities and scripts
apiVersion: v1
kind: ConfigMap
metadata:
  name: monitoring-test-scripts
  namespace: oran-monitoring
  labels:
    app.kubernetes.io/name: monitoring-test-scripts
    app.kubernetes.io/component: test
    app.kubernetes.io/part-of: oran-intent-mano
data:
  test-queries.json: |
    {
      "basic_queries": [
        "up",
        "prometheus_build_info",
        "node_cpu_seconds_total",
        "container_cpu_usage_seconds_total"
      ],
      "oran_queries": [
        "oran_intent_processing_duration_seconds",
        "oran_slice_deployment_duration_seconds",
        "oran_vnf_placement_total",
        "oran_network_slice_throughput_mbps",
        "oran_ping_rtt_milliseconds"
      ],
      "performance_queries": [
        "rate(prometheus_http_requests_total[5m])",
        "histogram_quantile(0.95, rate(prometheus_http_request_duration_seconds_bucket[5m]))",
        "avg_over_time(up[5m])",
        "topk(10, rate(node_cpu_seconds_total[5m]))"
      ],
      "aggregation_queries": [
        "avg_over_time(up[1h]) by (job)",
        "rate(prometheus_tsdb_head_samples_appended_total[5m])",
        "prometheus_tsdb_head_series"
      ]
    }

  expected-targets.json: |
    {
      "required_targets": [
        "kubernetes-apiservers",
        "kubernetes-nodes",
        "kubernetes-pods",
        "prometheus"
      ],
      "optional_targets": [
        "oran-nlp",
        "oran-orchestrator",
        "oran-ran",
        "oran-cn",
        "oran-tn",
        "oran-vnf-operator",
        "trivy-operator"
      ],
      "minimum_healthy_targets": 3
    }

  performance-thresholds.json: |
    {
      "query_latency_ms": {
        "simple_queries": 100,
        "complex_queries": 500,
        "range_queries": 1000
      },
      "cardinality_limits": {
        "max_series_per_component": 10000,
        "max_total_series": 100000
      },
      "resource_usage": {
        "max_memory_growth_percent": 50,
        "max_cpu_utilization_percent": 80
      }
    }